# Recompiler Testing Workflow

This document outlines the testing strategy for the `CrashRecomp` project. The process is based on **Golden File Testing**.

The core idea is to have a "golden" C++ output file that represents the known, correct output for a given assembly input. Every time you make a change, you regenerate the output and compare it to the golden file. If they match, your changes didn't break anything. If they don't, you either introduced a bug or you've added a new feature that requires updating the golden file.

## The Key Files

-   `recompiler_tool/test.asm`: This is your **input**. It contains the MIPS assembly instructions you want to test.
-   `recompiler_tool/recompiler_output.golden.cpp`: This is your **expected output**. It's the "master" copy of what the C++ should look like for `test.asm`. You should only change this file deliberately.
-   `recompiler_tool/recompiler_output.current.cpp`: This is the **actual output** generated by your recompiler during the most recent test run. This file is temporary and gets overwritten every time you run the test.
-   `recompiler_tool/run_recompiler_test.sh`: This is your **test runner**. It automates the process of assembling `test.asm`, running your recompiler to produce `recompiler_output.current.cpp`, and comparing it against `recompiler_output.golden.cpp`.

---

## Scenario A: Running Existing Tests (Verifying No Regressions)

Use this workflow when you've refactored or changed existing code in `recompiler_tool/main.cpp` and want to make sure you haven't broken anything.

1.  **Navigate to the Build Directory:**
    ```bash
    cd /home/amena/Desktop/CrashRecomp/recompiler_tool/build
    ```

2.  **Configure and Build:** Run `cmake` and `make` to ensure your `recompiler_tool` executable is up-to-date with your latest changes.
    ```bash
    cmake ..
    make
    ```

3.  **Run the Test Script:**
    ```bash
    ./run_recompiler_test.sh
    ```

4.  **Interpret the Results:**
    *   **If there is NO output:** Congratulations! Your changes did not alter the output for the existing tests. Nothing was broken. This is a **PASS**.
    *   **If you see `diff` output:** The test has **FAILED**. The output shows the difference between the `golden` file and the `current` file. This means your changes caused the generated C++ to be different from what's expected. You need to investigate your changes in `main.cpp` to fix the regression.

---

## Scenario B: Adding a New Test (Implementing a New Instruction)

This is the workflow you will use most often as you add support for new MIPS instructions.

Let's say you want to add support for the `AND` instruction.

1.  **Step 1: Implement the Instruction in the Recompiler:**
    *   Open `recompiler_tool/main.cpp`.
    *   Add your `case MIPS_INS_AND: { ... }` block to the `switch` statement, writing the logic to generate the correct C++ for the `AND` instruction.

2.  **Step 2: Add the Instruction to the Test Case:**
    *   Open `recompiler_tool/test.asm`.
    *   Add one or more `and` instructions to the assembly code to ensure your new implementation gets tested. For example:
        ```mips
        # ... other instructions ...
        and $s3, $t0, $t1  # Test AND
        # ... other instructions ...
        ```

3.  **Step 3: Build Your Updated Recompiler:**
    *   Navigate to the build directory and run `make`.
    ```bash
    cd /home/amena/Desktop/CrashRecomp/recompiler_tool/build
    make
    ```

4.  **Step 4: Run the Test Script (And Expect a Failure):**
    *   Run the test script. It is **expected to fail** this time.
    ```bash
    ./run_recompiler_test.sh
    ```
    *   The `diff` output will show the new lines for the `and` instruction that are in `recompiler_output.current.cpp` but not yet in the `golden` file.

5.  **Step 5: Manually Verify the New Output:**
    *   Carefully examine the `diff` output. Look at the C++ code that was generated for your new `and` instruction.
    *   **Ask yourself: "Is this the correct C++ translation?"**
    *   If it's not correct, go back to Step 1 and fix your logic in `main.cpp`.
    *   If it **is** correct, proceed to the next step.

6.  **Step 6: Promote the Current Output to the Golden Master:**
    *   Since your new output is correct, you need to update the golden file to include it. This "blesses" the new output as the correct version for all future tests.
    *   From the `recompiler_tool` directory, run:
    ```bash
    cp recompiler_output.current.cpp recompiler_output.golden.cpp
    ```
    *(Note: Make sure you are in the `recompiler_tool` directory, not the `build` directory, for this command, or adjust the paths accordingly).*

7.  **Step 7: Re-run the Test for Confirmation:**
    *   Run the test script one more time from the `build` directory:
    ```bash
    ./run_recompiler_test.sh
    ```
    *   This time, there should be **no output**. The test now **PASSES** because your `current` and `golden` files are identical.

You have now successfully added a new instruction to your recompiler and integrated it into your test suite. You can repeat this process for every new instruction you implement.
