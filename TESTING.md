# Recompiler Testing Workflow

This document outlines the testing strategy for the `CrashRecomp` project. The process is based on **Golden File Testing**.

The core idea is to have a "golden" C++ output file that represents the known, correct output for a given assembly input. Every time you make a change, you regenerate the output and compare it to the golden file. If they match, your changes didn't break anything. If they don't, you either introduced a bug or you've added a new feature that requires updating the golden file.

## The Key Files

-   `recompiler_tool/test.asm`: This is your **input**. It contains the MIPS assembly instructions you want to test.
-   `recompiler_tool/recompiler_output.golden.cpp`: This is your **expected output**. It's the "master" copy of what the C++ should look like for `test.asm`. You should only change this file deliberately.
-   `recompiler_tool/recompiler_output.current.cpp`: This is the **actual output** generated by your recompiler during the most recent test run. This file is temporary and gets overwritten every time you run the test.
-   `recompiler_tool/run_recompiler_test.sh`: This is your **test runner**. It automates the process of assembling `test.asm`, running your recompiler to produce `recompiler_output.current.cpp`, and comparing it against `recompiler_output.golden.cpp`.

---

## Scenario A: Running Existing Tests (Verifying No Regressions)

Use this workflow when you've refactored or changed existing code in `recompiler_tool/main.cpp` and want to make sure you haven't broken anything.

1.  **Navigate to the Build Directory:**
    ```bash
    cd /home/amena/Desktop/CrashRecomp/recompiler_tool/build
    ```

2.  **Configure and Build:** Run `cmake` and `make` to ensure your `recompiler_tool` executable is up-to-date with your latest changes.
    ```bash
    cmake ..
    make
    ```

3.  **Run the Test Script:**
    ```bash
    ./run_recompiler_test.sh
    ```

4.  **Interpret the Results:**
    *   **If there is NO output:** Congratulations! Your changes did not alter the output for the existing tests. Nothing was broken. This is a **PASS**.
    *   **If you see `diff` output:** The test has **FAILED**. The output shows the difference between the `golden` file and the `current` file. This means your changes caused the generated C++ to be different from what's expected. You need to investigate your changes in `main.cpp` to fix the regression.

---

## Scenario B: Adding a New Test (Implementing a New Instruction)

This is the workflow you will use most often as you add support for new MIPS instructions.

Let's say you want to add support for the `AND` instruction.

1.  **Step 1: Implement the Instruction in the Recompiler:**
    *   Open `recompiler_tool/main.cpp`.
    *   Add your `case MIPS_INS_AND: { ... }` block to the `switch` statement, writing the logic to generate the correct C++ for the `AND` instruction.

2.  **Step 2: Add the Instruction to the Test Case:**
    *   Open `recompiler_tool/test.asm`.
    *   Add one or more `and` instructions to the assembly code to ensure your new implementation gets tested. For example:
        ```mips
        # ... other instructions ...
        and $s3, $t0, $t1  # Test AND
        # ... other instructions ...
        ```

3.  **Step 3: Build Your Updated Recompiler:**
    *   Navigate to the build directory and run `make`.
    ```bash
    cd /home/amena/Desktop/CrashRecomp/recompiler_tool/build
    make
    ```

4.  **Step 4: Run the Test Script (And Expect a Failure):**
    *   Run the test script. It is **expected to fail** this time.
    ```bash
    ./run_recompiler_test.sh
    ```
    *   The `diff` output will show the new lines for the `and` instruction that are in `recompiler_output.current.cpp` but not yet in the `golden` file.

5.  **Step 5: Manually Verify the New Output:**
    *   Carefully examine the `diff` output. Look at the C++ code that was generated for your new `and` instruction.
    *   **Ask yourself: "Is this the correct C++ translation?"**
    *   If it's not correct, go back to Step 1 and fix your logic in `main.cpp`.
    *   If it **is** correct, proceed to the next step.

6.  **Step 6: Promote the Current Output to the Golden Master:**
    *   Since your new output is correct, you need to update the golden file to include it. This "blesses" the new output as the correct version for all future tests.
    *   From the `recompiler_tool` directory, run:
    ```bash
    cp recompiler_output.current.cpp recompiler_output.golden.cpp
    ```
    *(Note: Make sure you are in the `recompiler_tool` directory, not the `build` directory, for this command, or adjust the paths accordingly).*

7.  **Step 7: Re-run the Test for Confirmation:**
    *   Run the test script one more time from the `build` directory:
    ```bash
    ./run_recompiler_test.sh
    ```
    *   This time, there should be **no output**. The test now **PASSES** because your `current` and `golden` files are identical.

You have now successfully added a new instruction to your recompiler and integrated it into your test suite. You can repeat this process for every new instruction you implement.


# TESTING ON WINDOWS

  Building the Project

  This process will compile recompiler.cpp, recompiler.h, and main.cpp into the recompiler_tool.exe executable. It will also compile recompiler_test.cpp into the RecompilerTests.exe executable.

   1. Generate the Visual Studio Solution:
      First, you need to run CMake to generate the project files. You only need to do this once, or whenever you change CMakeLists.txt.
       * Create a build directory inside recompiler_tool.
       * Open a command prompt or PowerShell, navigate into the build directory, and run CMake.

   1     cd C:\Users\Owner\Desktop\PS2_Recomp\Ps2Recomp\recompiler_tool
   2     mkdir build
   3     cd build
   4     cmake ..
      This will create a Ps2Recomp.sln file inside the build directory.

   2. Compile the Code:
      You can now build the project in one of two ways:

       * Option A (Command Line): From the same command prompt inside the build directory, run:

   1         # To build in Debug mode
   2         cmake --build . --config Debug
   3 
   4         # Or to build in Release mode
   5         cmake --build . --config Release

       * Option B (Visual Studio IDE):
           * Open the Ps2Recomp.sln file (located in the build directory) with Visual Studio.
           * In the Solution Explorer, you will see your targets (recompiler_tool, RecompilerTests).
           * Build the entire solution by going to the menu and selecting Build > Build Solution.

  After this, you will find your compiled executables inside the build\Debug or build\Release directory.

  Testing recompiler_test.cpp

  Because you've set up GoogleTest correctly in your CMakeLists.txt, running your tests is very simple.

   1. Build the `RecompilerTests` target using either of the build methods described above. This is done automatically if you "Build Solution".

   2. Run the tests:

       * Option A (Command Line): From the command prompt in the build directory, run CTest. It will automatically find and run your tests.
   1         # Make sure you are in the 'build' directory
   2         ctest
          It will print a summary of which tests passed or failed.

       * Option B (Visual Studio IDE - Recommended):
           * With the solution open, go to the menu and select Test > Test Explorer.
           * A "Test Explorer" window will open and automatically discover the tests from your recompiler_test.cpp file (e.g., AnalysisHelpers.IsBranchLikely).
           * Click the "Run All Tests In View" button (a green play icon) in the Test Explorer to run the tests and see the results directly in the IDE.